<!--suppress EqualityComparisonWithCoercionJS -->
<html>

<style>
div.sidebar {
	position: absolute;
	left: 524px;
	top: 10px;
}
div.player_div {
	min-width: 150px;
	padding: 20px;
	border:1px solid black;
}
</style>
<body>

<span style="display:none;">
   <img id="moon" src="moon.png">
   <img id="star" src="star.png">
   <img id="gear" src="gear.png">
   <img id="saturn" src="saturn.png">
   <img id="warp" src="warp.png">
   <img id="red" src="red.png">
   <img id="blue" src="blue.png">
   <img id="green" src="green.png">
   <img id="yellow" src="yellow.png">
   <img id="grey" src="grey.png">
</span>

<div id="player_list" class="sidebar"></div>

<canvas id="MainCanvas" width="512" height="512" style="border:1px solid #c3c3c3;">
</canvas>

<br>

<span id="game_info"></span>
<br>

<span class="bid solve free">
	<span id="timer"></span>  <span id="num_moves" class="solve"></span>
	<br>
</span>

<span class="playing bid solve">
	<input id="bid_input" type="text" class="playing bid"></input>
	<button id="bid" class="playing bid">Bid</button>
	<span id="curr_bid"></span>
	<button id="gentleman" class="playing bid">Skip Round</button>
	<br>
</span>

<span class="playing solving">
	<span id="turn_indicator">Your Turn!<br></span>
	<button id="revert">Revert</button>
	<button id="undo">Undo</button>
	<button id="redo">Redo</button>
	<button id="skip">Give Up</button>
	<br>
</span>

<span class="playing free end">
	<button id="demo">View Optimal</button>
	<button id="reset_robots">Reset Robots</button>
	<button id="next" class="playing free">Next Round</button>
	<button id="wait" class="playing free">Wait Please</button>
	<br>
	<span id="solution_indicator"></span>
	<br>
</span>

<span class="playing">
	Name: <span id="name"></span>
	<br>
	Score: <span id="score"></span>
	<br>
</span>

<input id="name_input" type="text" class="" ></input>
<button id="join_game" class="observing">Join</button>
<button id="rename_button" class="playing">Rename</button>
<br>

<button id="leave_game" class="playing">Leave</button>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<script type="module" src="/util.js"></script>
<script type="module" src="/robots.js"></script>

<script type="module">

import { Point, Direction, strcmp, intdiv, arrayRemove, arrayFind, isAnyOf, toIntegerEnumeration } from "./util.js";
import { Game, State, Color, Symbol, RobotMove, Goal } from "./robots.js";
import { TILE_SIZE, getMousePos, getCellFromPos, clearCanvas, getSymbolImage, getRobotImage, getColorValue, drawGoal, drawStartPoint, drawBoard } from "./draw.js";

const ROBOT_TWEEN_SPEED = 32.0;
const TIME_SYNC_INTERVAL = 1000 * 60 * 5; // Once every few minutes?

const MAX_SOLVE_BUFFER = 5;
const MAX_FREE_BUFFER = 2;

let bidInput = document.getElementById('bid_input');
let nameInput = document.getElementById('name_input');
let revertButton = document.getElementById('revert');
let undoButton = document.getElementById('undo');
let redoButton = document.getElementById('redo');
let skipSolveButton = document.getElementById('skip');
let bidButton = document.getElementById('bid');
let joinButton = document.getElementById('join_game');
let leaveButton = document.getElementById('leave_game');
let renameButton = document.getElementById('rename_button');
let nextRoundButton = document.getElementById('next');
let waitRoundButton = document.getElementById('wait');
let gentlemanButton = document.getElementById('gentleman');
let resetRobotsButton = document.getElementById('reset_robots');
let showDemoButton = document.getElementById('demo');
let pendingFocusElement = nameInput;

function getColorValueArrow(color) {
	if (color == Color.Yellow) {
		return "#AAAA22";
	} else if (color == Color.Green) {
		return "#22AA22";
	} else if (color == Color.Red) {
		return "#AA2222";
	} else if (color == Color.Blue) {
		return "#2222AA";
	} else {
		return "#FFFFFF";
	}
}

class ActiveSelection {
	constructor(game) {
		this.game = game;
		this.selectedRobot = null;
		Object.defineProperty(this, 'directionMoves', { 'value': new Array(4) });
	}
	
	setRobot(robotId) {
		this.selectedRobot = robotId;
		if (this.hasSelection()) {
			for (let dir = 0; dir < 4; ++dir) {
				this.directionMoves[dir] = []
				this.game.board.doMove(this.game.getRobotPositions(), this.selectedRobot, dir, this.directionMoves[dir]);
			}
		}
	}
	
	getMoveEndpoint(dir) {
		return this.directionMoves[dir][this.directionMoves[dir].length - 1];
	}
	
	hasSelection() {
		return this.selectedRobot != null;
	}
	
	clearSelection() {
		this.selectedRobot = null;
	}
}

class Robot {
	constructor(game, position, color) {
		Object.defineProperty(this, 'color', { 'value': color });
		this.game = game;
		this.positionQueue = [position]
		this.tweenAlpha = 0.0;
	}
	
	moveTo(cell) {
		if (this.positionQueue.length > 0 && this.positionQueue[this.positionQueue.length - 1].equals(cell)) {
			return;
		}
		this.positionQueue.push(cell);
		this.game.robots[this.color] = cell;
	}
	
	warpTo(cell) {
		this.positionQueue = [cell];
		this.game.robots[this.color] = cell;
		this.tweenAlpha = 0.0;
	}
	
	getCell() {
		return this.positionQueue[this.positionQueue.length - 1];
	}
	
	update(deltaTime) {
		if (this.positionQueue.length > 1) {
			let dist = this.positionQueue[0].lInfDist(this.positionQueue[1]);
			this.tweenAlpha = Math.min(this.tweenAlpha + (deltaTime * ROBOT_TWEEN_SPEED) / dist, 1.0);
			
			if (this.tweenAlpha >= 1.0) {
				this.positionQueue.shift();
				this.tweenAlpha = 0.0;
			}
		}
	}
	
	getDrawPosition(offset = new Point(0, 0)) {
		let basePosition;
		if (this.positionQueue.length == 1) {
			basePosition = this.positionQueue[0].mul(TILE_SIZE);
		} else {
			basePosition = this.positionQueue[0].mul(TILE_SIZE * (1 - this.tweenAlpha)).add(this.positionQueue[1].mul(TILE_SIZE * this.tweenAlpha));
		}
		return basePosition.add(offset);
	}
	
	getImage() {
		return getRobotImage(this.color);
	}
	
	getColorValue() {
		return getColorValue(this.color);
	}

	cancelTween() {
		this.warpTo(this.getCell());
	}
	
	draw(canvas, offset = new Point(0, 0)) {
		let ctx = canvas.getContext("2d");
		let pos = this.getDrawPosition(offset);
		ctx.drawImage(this.getImage(), pos.x, pos.y);
	}
}

class SandTimer {
	static COLOR = "#DD1111";
	static LINE_THICKNESS = 5.0;

	constructor(x1, x2, y1, y2) {
		this.x1 = Math.min(x1, x2);
		this.x2 = Math.max(x1, x2);
		this.y1 = Math.min(y1, y2);
		this.y2 = Math.max(y1, y2);

		this.tweenAlpha = 0.0;
		this.onTimeUp = null;
	}

	draw(canvas) {
		let ctx = canvas.getContext("2d");

		let hLength = Math.abs(this.x2 - this.x1);
		let vLength = Math.abs(this.y2 - this.y1);
		let perimeterLength = 2 * hLength + 2 * vLength;

		let hProp = hLength / perimeterLength;
		let vProp = vLength / perimeterLength;

		ctx.strokeStyle = SandTimer.COLOR;
		ctx.lineWidth = SandTimer.LINE_THICKNESS;
		ctx.lineCap = "square";

		// draw left side
		if(this.tweenAlpha > vProp + 2 * hProp) {
			ctx.beginPath();
			ctx.moveTo(this.x1, this.y1  + vLength * (1 - (this.tweenAlpha - (vProp + 2 * hProp)) / vProp));
			ctx.lineTo(this.x1, this.y2);
			ctx.stroke();
		}

		// draw bottom side
		if(this.tweenAlpha > vProp + hProp) {
			ctx.beginPath();
			ctx.moveTo(this.x1 + hLength * (1 - (Math.min(this.tweenAlpha, vProp + 2 * hProp) - (vProp + hProp)) / hProp), this.y2);
			ctx.lineTo(this.x2, this.y2);
			ctx.stroke();
		}

		// draw right side
		if(this.tweenAlpha > hProp) {
			ctx.beginPath();
			ctx.moveTo(this.x2, this.y1 + vLength * (Math.min(this.tweenAlpha, vProp + hProp) - vProp) / vProp);
			ctx.lineTo(this.x2, this.y1);
			ctx.stroke();
		}

		// draw top side
		if(this.tweenAlpha > 0) {
			ctx.beginPath();
			ctx.moveTo(this.x1 + hLength * (Math.min(this.tweenAlpha, hProp) / hProp), this.y1);
			ctx.lineTo(this.x1, this.y1);
			ctx.stroke();
		}

		ctx.lineCap = "butt";
	}

	update(currTime, totalTime) {
		this.tweenAlpha =  currTime / totalTime;
	}

	setOnTimeUp(onTimeUp) {
		this.setOnTimeUp = onTimeUp;
	}

	cancel() {
		this.tweenAlpha = 0.0;
		this.timeLeft = 0;
	}
}

// Globals
let game = new Game();
let robots = [];

let selection = new ActiveSelection(game);
let canvas = document.getElementById("MainCanvas");
let moveSequence = [];
let redoStack = [];
let moveCount = null;

let demoAvailable = false;
let demoCurrentMove = null;
let demoSequence = null;
let cachedRobotPositions = [];

let arrowSequence = [];
let activeTimer = new SandTimer(0, game.board.width * TILE_SIZE, 0, game.board.height * TILE_SIZE);

let playerId = null;
let currentSolvingPlayer = null;

let serverTimeDelta = 0;
let serverStartTime = null;

let socket = null;

let timeSyncTimeoutId = null;

function isViewingDemo() {
	return demoCurrentMove != null;
}

class MoveArrow {
	static ARROW_SIZE = 6;
	static PADDING = 5;
	static LINE_THICKNESS = 1.5;
	static DODGE_WIDTH = 4;
	static MAX_PER_TILE = 7;

	static cellHCount = Array(game.board.width * game.board.height).fill(0);
	static cellVCount = Array(game.board.width * game.board.height).fill(0);
	static finalRobotPositions = [];

	constructor(start, end, color, game, moveId) {
		this.startPoint = start;
		this.endPoint = end;
		this.color = color;
		this.moveId = moveId;
		this.game = game;
		this.tweenAlpha = 0;
		this.nextArrow = null;
		this.prevArrow = null;

		this.updateCellCount();
		this.dodge = this.findMaxLineCount() - 1;
	}

	static clearCellCounts() {
		MoveArrow.cellHCount = Array(game.board.width * game.board.height).fill(0);
		MoveArrow.cellVCount = Array(game.board.width * game.board.height).fill(0);
	}

	static setFinalPosition(robotID, x, y) {
		MoveArrow.finalRobotPositions[robotID] = new Point(x, y);
	}

	static clearFinalPositions() {
		MoveArrow.finalRobotPositions = [];
	}

	static drawCellCounts() {
		for(let y = 0; y < game.board.height; y++) {
			for(let x = 0; x < game.board.width; x++) {
				let ctx = canvas.getContext("2d");

				let str = Math.max(MoveArrow.cellHCount[y * game.board.height + x], MoveArrow.cellVCount[y * game.board.height + x])
				ctx.fillText(str, (x + 0.5) * TILE_SIZE, (y + 0.5) * TILE_SIZE);
			}
		}
	}

	#isCellFull(cell) {
		let result = false;

		if(this.game.board.getCell(cell).getGoal() || this.game.board.getCell(cell).getBumper() != null) {
			result = true;
		}

		if(isViewingDemo()) {
			for(let i in this.game.robots) {
				if(cell.equals(MoveArrow.finalRobotPositions[i])) {
					result = true;
				}
			}
		}

		return result;
	}

	#drawArrowHead(x, y, theta) {
		let ctx = canvas.getContext("2d");

		ctx.strokeStyle = getColorValueArrow(this.color);
		ctx.lineWidth = MoveArrow.LINE_THICKNESS;

		ctx.beginPath();
		ctx.moveTo(x, y);
		ctx.lineTo(x + Math.cos(theta + 5 * Math.PI / 4) * MoveArrow.ARROW_SIZE, y - Math.sin(theta + 5 * Math.PI / 4) * MoveArrow.ARROW_SIZE);
		ctx.stroke();

		ctx.beginPath();
		ctx.moveTo(x, y);
		ctx.lineTo(x + Math.cos(theta + 3 * Math.PI / 4) * MoveArrow.ARROW_SIZE, y - Math.sin(theta + 3 * Math.PI / 4) * MoveArrow.ARROW_SIZE)
		ctx.stroke();
	}

	connectTo(nextArrow) {
		this.nextArrow = nextArrow;
		nextArrow.prevArrow = this;
	}

	getDirection() {
		return this.endPoint.sub(this.startPoint).getDirection();
	}

	getLength() {
		return this.startPoint.lInfDist(this.endPoint)
	}

	getCellArray()
	{
		let direction = this.getDirection();

		if (direction == Direction.Left || direction == Direction.Right)
		{
			return MoveArrow.cellHCount;
		}
		else
		{
			return MoveArrow.cellVCount;
		}
	}

	removeCellCount() {
		this.updateCellCount(true);
	}

	updateCellCount(reverse = false) {
		let delta = reverse ? -1 : 1;

		let currPoint = this.startPoint;
		let direction = Point.fromDirection(this.getDirection());
		let cellArray = this.getCellArray();

		cellArray[currPoint.y * game.board.height + currPoint.x] += delta;

		do {
			currPoint = currPoint.add(direction);
			cellArray[currPoint.y * game.board.height + currPoint.x] += delta;
		} while(!currPoint.equals(this.endPoint))
	}

	findMaxLineCount() {
		let currPoint = this.startPoint;
		let cellArray = this.getCellArray();

		let max = cellArray[this.startPoint.y * game.board.height + this.startPoint.x];
		let directionUnit = Point.fromDirection(this.getDirection());

		do {
			currPoint = currPoint.add(directionUnit);
			let curr = cellArray[currPoint.y * game.board.height + currPoint.x];

			if(curr > max) {
				max = curr;
			}
		} while(!currPoint.equals(this.endPoint))

		return max;
	}

	getStartX() {
		let direction = this.getDirection();
		let offset = TILE_SIZE / 2;

		let fullStartCellAdjustment = this.#isCellFull(this.startPoint) ? offset : MoveArrow.PADDING;
		let x1 = this.startPoint.x * TILE_SIZE + offset;

		// shrink arrow length if start cell is full
		x1 = x1 - (fullStartCellAdjustment) * (direction % 2 - 1) * (direction - 1);

		// displace arrow to the side if cells in the arrow's path already contain arrows
		x1 += MoveArrow.DODGE_WIDTH  * (direction % 2) * toIntegerEnumeration(this.dodge);

		return x1;
	}

	getStartY() {
		let direction = this.getDirection();
		let offset = TILE_SIZE / 2;

		let fullStartCellAdjustment = this.#isCellFull(this.startPoint) ? offset : MoveArrow.PADDING;
		let y1 = this.startPoint.y * TILE_SIZE + offset;

		// shrink arrow length if start cell is full
		y1 = y1 + (fullStartCellAdjustment) * (direction % 2) * (direction - 2);

		// displace arrow to the side if cells in the arrow's path already contain arrows
		y1 += MoveArrow.DODGE_WIDTH * (direction % 2 - 1) * toIntegerEnumeration(this.dodge);

		return y1;
	}

	getEndX() {
		let direction = this.getDirection();
		let offset = TILE_SIZE / 2;

		let fullDestCellAdjustment = this.#isCellFull(this.endPoint) ? offset : MoveArrow.PADDING;
		let x2 = this.endPoint.x * TILE_SIZE + offset;

		// shrink arrow length if destination cell is full
		x2 = x2 + (fullDestCellAdjustment) * (direction % 2 - 1) * (direction - 1);

		// displace arrow to the side if cells in the arrow's path already contain arrows
		x2 += MoveArrow.DODGE_WIDTH * (direction % 2) * toIntegerEnumeration(this.dodge);

		return x2;
	}

	getEndY() {
		let direction = this.getDirection();
		let offset = TILE_SIZE / 2;

		let fullDestCellAdjustment = this.#isCellFull(this.endPoint) ? offset : MoveArrow.PADDING;
		let y2 = this.endPoint.y * TILE_SIZE + offset;

		// shrink arrow length if destination cell is full
		y2 = y2 - (fullDestCellAdjustment) * (direction % 2) * (direction - 2);

		// displace arrow to the side if cells in the arrow's path already contain arrows
		y2 += MoveArrow.DODGE_WIDTH * (direction % 2 - 1) * toIntegerEnumeration(this.dodge);

		return y2;
	}

	draw(canvas) {
		let ctx = canvas.getContext("2d");
		let direction = this.getDirection();

		// place start and end points in center of tile
		let x1 = this.getStartX();
		let y1 = this.getStartY();
		let x2 = this.getEndX();
		let y2 = this.getEndY();

		// if the arrow bends, speed up tweening to allow some time to animate tween around the bend
		let elongated = (this.getLength() + 1) / this.getLength();
		let adjustedTween = this.tweenAlpha;

		// adjust start length for end of a curve
		if (this.prevArrow) {
			let x3 = this.prevArrow.getEndX();
			let y3 = this.prevArrow.getEndY();
			let r = Math.min(Math.abs(x1-x3), Math.abs(y1-y3));

			x1 = x1 + (Math.abs(x3 - x1) - r) * (direction % 2 - 1) * (direction - 1);
			y1 = y1 - (Math.abs(y3 - y1) - r) * (direction % 2) * (direction - 2);
		}

		// adjust end length for start of a curve
		if (this.nextArrow) {
			let x3 = this.nextArrow.getStartX();
			let y3 = this.nextArrow.getStartY();
			let r = Math.min(Math.abs(x2-x3), Math.abs(y2-y3));

			x2 = x2 - (Math.abs(x3 - x2) - r) * (direction % 2 - 1) * (direction - 1);
			y2 = y2 + (Math.abs(y3 - y2) - r) * (direction % 2) * (direction - 2);

			adjustedTween = Math.min(1, this.tweenAlpha * elongated);
		}

		// for some nice arrow tweening
		if(direction == Direction.Left || direction == Direction.Right) {
			x2 = x1 + (x2 - x1) * adjustedTween;
		} else {
			y2 = y1 + (y2 - y1) * adjustedTween;
		}

		if(this.dodge < MoveArrow.MAX_PER_TILE)
		{
			ctx.strokeStyle = getColorValueArrow(this.color);
			ctx.lineWidth = MoveArrow.LINE_THICKNESS;

			// arrow shaft
			ctx.beginPath();
			ctx.moveTo(x1, y1);
			ctx.lineTo(x2, y2);
			ctx.stroke();

			// draw bend in arrow
			if (this.nextArrow && adjustedTween >= 1)
			{
				let x3 = this.nextArrow.getStartX();
				let y3 = this.nextArrow.getStartY();
				let nextDirection = this.nextArrow.getDirection();

				let r = Math.min(Math.abs(x2 - x3), Math.abs(y2 - y3));
				let ccw = (Direction.rotate90(direction, -1) == nextDirection);

				let startBend = 1 / elongated;
				let dTheta = (this.tweenAlpha - startBend) / (1 - startBend) * Math.PI / 2;
				let thetaStart = -1 * Direction.toRadians(direction) - Math.PI / 2 * (ccw ? -1 : 1);
				let thetaEnd = thetaStart + dTheta * (ccw ? -1 : 1);

				// adjust coordinates of next arrow's start point
				x3 = x3 + (Math.abs(x2 - x3) - r) * (nextDirection % 2 - 1) * (nextDirection - 1);
				y3 = y3 - (Math.abs(y2 - y3) - r) * (nextDirection % 2) * (nextDirection - 2);

				let cx, cy;
				if (direction == Direction.Right || direction == Direction.Left)
				{
					cx = x2;
					cy = y3;
				}
				else
				{
					cx = x3;
					cy = y2;
				}

				ctx.beginPath();
				ctx.arc(cx, cy, r, thetaStart, thetaEnd, ccw);
				ctx.stroke();

				if (this.tweenAlpha < 1.0)
				{
					let arrowAngle = -1 * thetaEnd + Math.PI / 2 * (ccw ? -1 : 1) + Math.PI;
					this.#drawArrowHead(cx + Math.cos(thetaEnd) * r, cy + Math.sin(thetaEnd) * r, arrowAngle);
				}

			}
			else
			{
				this.#drawArrowHead(x2, y2, Direction.toRadians(direction));
			}
		}
	}

	cancelTween() {
		this.tweenAlpha = 1.0;
	}

	update(deltaTime) {
		let dist = this.startPoint.lInfDist(this.endPoint);
		this.tweenAlpha = Math.min(this.tweenAlpha + (deltaTime * ROBOT_TWEEN_SPEED) / dist, 1.0);
	}
}

function drawGame(game, canvas, offset = new Point(0, 0)) {
	clearCanvas(canvas);
	drawBoard(game.board, canvas, offset);

	if (game.originalRobotConfig != null) {
		for (let i = 0; i < game.originalRobotConfig.length; ++i) {
			drawStartPoint(game.originalRobotConfig[i], i, canvas, offset);
		}
	}

	for (let i = 0; i < robots.length; ++i) {
		robots[i].draw(canvas, offset);
	}

	if (selection.hasSelection()) {
		let ctx = canvas.getContext("2d");
		ctx.fillStyle = robots[selection.selectedRobot].getColorValue();
		ctx.globalAlpha = 0.3;
		let current = robots[selection.selectedRobot].getCell();
		let currentDraw = current.mul(TILE_SIZE).add(offset);
		ctx.fillRect(currentDraw.x, currentDraw.y, TILE_SIZE, TILE_SIZE);

		for (let dir = 0; dir < 4; ++dir) {
			current = robots[selection.selectedRobot].getCell();
			for (let segment = 1; segment < selection.directionMoves[dir].length; ++segment) {
				// TODO: will need to cover the entire path (or at least all segments of the path) if we add bumpers
				let extent = selection.directionMoves[dir][segment];
				let delta = selection.directionMoves[dir][segment].sub(selection.directionMoves[dir][segment - 1]);
				delta = Point.fromDirection(delta.getDirection());
				while (!extent.equals(current)) {
					current = current.add(delta);
					currentDraw = current.mul(TILE_SIZE).add(offset);
					ctx.fillRect(currentDraw.x, currentDraw.y, TILE_SIZE, TILE_SIZE);

					if (current.x < 0 || current.y < 0 || current.x >= game.board.size.x || current.y >= game.board.size.y) {
						selection.setRobot(selection.selectedRobot);
						break;
					}
				}
			}
		}
		ctx.globalAlpha = 1.0;
	}

	if (game.currentGoal != null) {
		drawGoal(game.currentGoal, canvas, game.board.size.mul(TILE_SIZE / 2.0).sub(TILE_SIZE / 2.0, TILE_SIZE / 2.0));
	}
}

function updateUI() {
	if (playerId == null) {
		$('.observing').show();
	} else {
		$('.playing').show();
	}

	let hideStates = State.allValues.filter(s => s != game.state).map(s => "." + State.str(s).toLowerCase());

	if (!isClientSolving()) {
		hideStates.push('.solving');
	}

	$(hideStates.join(', ')).hide();
	let showState = State.str(game.state).toLowerCase()
	$('.' + showState).show();

	if (playerId == null) {
		$('.playing').hide();
	} else {
		$('.observing').hide();
	}

	let timer = document.getElementById('timer');
	if (serverStartTime != null) {
		let serverNow = Date.now() + serverTimeDelta;
		let serverTimerElapsed = serverNow - serverStartTime;
		if (game.state == State.Bid) {
			let bidTimeLeft = Math.max((game.bidTimeout * 1000) - serverTimerElapsed, 0);
			timer.textContent = epochDeltaToTime(bidTimeLeft);
			activeTimer.update(bidTimeLeft, game.bidTimeout * 1000);
		} else if (game.state == State.Solve) {
			let solveTimeLeft = Math.max((game.solveTimeout * 1000) - serverTimerElapsed, 0);
			timer.textContent = epochDeltaToTime(solveTimeLeft);
			activeTimer.update(solveTimeLeft, game.solveTimeout * 1000);
		} else if (game.state == State.Free) {
			let nextRoundTimeLeft = Math.max((game.nextRoundTimeout * 1000) - serverTimerElapsed, 0);
			timer.textContent = epochDeltaToTime(nextRoundTimeLeft);
		} else if (game.state == State.Wait) {
			let revealTimeLeft = Math.max((game.revealTimeout * 1000) - serverTimerElapsed, 0);
			timer.textContent = epochDeltaToTime(revealTimeLeft);
			activeTimer.update(revealTimeLeft, game.revealTimeout * 1000);
		}

	} else {
		timer.textContent = "";
	}

	let numMoves = document.getElementById('num_moves');
	if (game.state == State.Solve && numMoves != null && moveCount != null) {
		numMoves.textContent = moveCount.toString();
	}

	if (playerId != null) {
		revertButton.disabled = !(isClientSolving() && hasUndo());
		undoButton.disabled = !(isClientSolving() && hasUndo());
		redoButton.disabled = !(isClientSolving() && hasRedo());

		bidInput.disabled = !canEnterBid();
		bidButton.disabled = !canBid();

		let currentBid = game.getBid(playerId);
		let currBidElement = document.getElementById('curr_bid');
		if (currentBid != null) {
			currBidElement.textContent = `Current Bid: ${currentBid.amount}`;
		} else {
			currBidElement.textContent = "";
		}

		let player = game.getPlayer(playerId);

		gentlemanButton.disabled = player.vote == 'SKIPBID';
		nextRoundButton.disabled = player.vote == 'NEXT';
		waitRoundButton.disabled = player.vote == 'WAIT';
		showDemoButton.disabled = !demoAvailable;

		if (isViewingDemo()) {
			resetRobotsButton.disabled = true;
			showDemoButton.innerText = 'Cancel Demo';
		} else {
			resetRobotsButton.disabled = false;
			showDemoButton.innerText = 'Show Demo';
		}

		document.getElementById('name').textContent = "" + player.name;
		document.getElementById('score').textContent = "" + player.getScore();
	}

	let namingDisabled = !canRename();
	joinButton.disabled = namingDisabled;
	renameButton.disabled = namingDisabled;

	if (pendingFocusElement != null) {
		pendingFocusElement.focus();
		pendingFocusElement = null;
	}

	updateTokenCount();
}

function canRename() {
	return nameInput.value.length > 0;
}

function skipSolve() {
	if (socket != null) {
		socket.send(`SKIP_SOLVE`);
	}
}

function voteGentleman() {
	if (socket != null) {
		socket.send(`VOTE SKIPBID`);
	}
}

function voteNextRound() {
	if (socket != null) {
		socket.send(`VOTE NEXT`);
	}
}

function voteWaitNextRound() {
	if (socket != null) {
		socket.send('VOTE WAIT');
	}
}

function viewOptimal() {
	if (isViewingDemo()) {
		cancelDemo()
	} else {
		if (demoSequence == null && socket != null) {
			socket.send(`VIEW_DEMO`);
		} else {
			startDemo();
		}
	}
}

function joinGame() {
	let nameValue = nameInput.value;
	if (nameValue.length > 0) {
		if (socket != null) {
			socket.send(`JOIN_GAME ${nameValue}`);
		} else {
			playerId = game.addPlayer(null, nameValue);
		}
	}
}

function leaveGame() {
	if (playerId != null) {
		game.removePlayer(playerId);
		if (socket != null) {
			socket.send(`LEAVE_GAME ${playerId}`);
		}
		playerId = null;
		pendingFocusElement = nameInput;
	}
}

function tryRename() {
	let nameValue = nameInput.value;
	if (playerId != null && nameValue.length > 0 && nameValue != game.getPlayer(playerId).name) {
		game.renamePlayer(playerId, nameValue);
		if (socket != null) {
			socket.send(`PLAYER_RENAME ${playerId} ${nameValue}`);
		}
	}
}

function canEnterBid() {
	if (game.getState() == State.Bid) {
		let currentBid = game.getBid(playerId);
		return currentBid == null || (game.allowMultipleBids && currentBid.amount > 2);
	}
	return false;
}

function canBid() {
	if (game.getState() == State.Bid) {
		let currentBid = game.getBid(playerId);
		let currentInputBid = getCurrentBidInputValue();
		return currentInputBid > 1 && (currentBid == null || (game.allowMultipleBids && currentInputBid != null && currentInputBid < currentBid.amount));
	}
	return false;
}

function getCurrentBidInputValue() {
	let bidText = bidInput.value;
	if (bidText.length > 0) {
		let asInt = parseInt(bidText);

		if (asInt > Number.MAX_SAFE_INTEGER) {
			asInt = 0;
		}

		return asInt;
	}
	return 0;
}

function executeBid() {
	if (canBid()) {
		let asInt = getCurrentBidInputValue();
		if (asInt > 1) {
			bidInput.value = '';
			if (socket != null) {
				socket.send(`MAKE_BID ${asInt}`);
			} else {
				game.setBid(playerId, asInt);
			}
		}
	}
}

function hasUndo() {
	return isClientSolving() && moveSequence.length > 0;
}

function undoMove() {
	if (!canDoMoves()) {
		return;
	}
	if (hasUndo()) {
		let lastMove = moveSequence.pop();
		redoStack.push(lastMove);
		moveCount = moveSequence.length;
		if (socket != null) {
			socket.send('UNDO_ROBOT');
		}

		let tempRobotPositions = game.getRobotPositions();
		tempRobotPositions[lastMove.color] = lastMove.position;
		let outMoves = [];
		game.board.doMove(tempRobotPositions, lastMove.color, lastMove.direction, outMoves);

		for (let i = outMoves.length - 2; i >= 0; --i) {
			robots[lastMove.color].moveTo(outMoves[i]);
		}

		filterArrowSequence(moveCount);
	}
	updateUI();
}

function hasRedo() {
	return isClientSolving() && redoStack.length > 0;
}

function redoMove() {
	if (!canDoMoves()) {
		return;
	}
	if (hasRedo()) {
		let addMove = redoStack.pop();
		moveSequence.push(addMove);
		moveCount = moveSequence.length;
		if (socket != null) {
			socket.send('REDO_ROBOT');
		}
		moveRobotInDirection(addMove.color, addMove.direction, game.state == State.Solve, moveCount - 1);
	}
	updateUI();
}

function revertMoves() {
	if (!canDoMoves()) {
		return;
	}
	game.resetRobotPositions();
	for (let i = 0; i < robots.length; ++i) {
		robots[i].warpTo(game.robots[i]);
	}
	if (isClientSolving()) {
		redoStack.push(...moveSequence.reverse());
		moveSequence = [];
		moveCount = 0;
	}
	clearMoveArrows();
	updateUI();

	if (socket != null) {
		socket.send('RESET_ROBOTS');
	}
}

function leftPad(v, x) {
	return v.toString().padStart(x, '0');
}

function epochDeltaToTime(deltaTime) {
	let millis = deltaTime % 1000;
	deltaTime = intdiv(deltaTime, 1000);
	let seconds = deltaTime % 60;
	deltaTime = intdiv(deltaTime, 60);
	let minutes = deltaTime;

	return `${minutes}:${leftPad(seconds, 2)}`
}

function canDoMoves() {
	return playerId != null && (isClientSolving() || isAnyOf(game.state, State.Free, State.End)) && !isViewingDemo();
}

function isClientSolving() {
	return currentSolvingPlayer != null && playerId != null && currentSolvingPlayer == playerId;
}

function getMaxBufferSize() {
	return isAnyOf(game.state, State.Free, State.End) ? MAX_FREE_BUFFER : MAX_SOLVE_BUFFER;
}

function doDirectionMove(direction) {
	if (selection.hasSelection()) {
		let target = selection.getMoveEndpoint(direction);
		if (!target.equals(robots[selection.selectedRobot].getCell())) {
			if (game.state == State.Solve) {
				moveSequence.push(new RobotMove(robots[selection.selectedRobot].getCell(), direction, robots[selection.selectedRobot].color));
				redoStack = [];
				moveCount = moveSequence.length;
				updateUI();
			}

			if (robots[selection.selectedRobot].positionQueue.length <= getMaxBufferSize()) {
				socket.send(`MOVE_ROBOT ${selection.selectedRobot} ${direction}`);
				moveRobotInDirection(selection.selectedRobot, direction, isAnyOf(game.state, State.Solve) || isViewingDemo(), moveCount - 1);
			}
			return true;
		}
	}
	return false;
}

function moveRobotInDirection(robotId, direction, addArrows = true, arrowMoveIndex = null) {
	let outMoves = []
	let target = game.board.doMove(game.getRobotPositions(), robotId, direction, outMoves);
	addArrows = true;
	if (!target.equals(robots[robotId].getCell())) {
		let lastPos = robots[robotId].getCell();
		for (let i = 1; i < outMoves.length; ++i) {
			robots[robotId].moveTo(outMoves[i]);
			if (addArrows) {
				arrowSequence.push(new MoveArrow(lastPos, outMoves[i], robotId, game, arrowMoveIndex));

				if(i > 1)
				{
					arrowSequence.at(-2).connectTo(arrowSequence.at(-1));
				}
			}
			lastPos = outMoves[i];
		}
	}
}

canvas.addEventListener('click', function(evt) {
	let mousePos = getMousePos(canvas, evt);
	let cellPos = getCellFromPos(mousePos);

	let didAction = false;
	let isFree = isAnyOf(game.state, State.Free, State.End);

	if (canDoMoves()) {
		if (selection.hasSelection()) {
			if (!robots[selection.selectedRobot].getCell().equals(cellPos)) {
				if (isFree && evt.shiftKey) {
					let cell = game.board.getCell(cellPos);
					if (arrayFind(game.robots, cellPos) == -1 && cell != null && !cell.fullyFenced() && cell.bumper === null) {
						if (robots[selection.selectedRobot].positionQueue.length <= getMaxBufferSize()) {
							socket.send(`FREE_MOVE_ROBOT ${selection.selectedRobot} ${cellPos.x} ${cellPos.y}`);
							robots[selection.selectedRobot].moveTo(cellPos);
						}
					}
					didAction = true;
				} else {
					for (let dir = 0; dir < 4; ++dir) {
						let target = selection.getMoveEndpoint(dir);
						if (target.equals(cellPos)) {
							didAction = doDirectionMove(dir);
						}
					}
				}
			}
		}

		if (!didAction) {
			selection.clearSelection();
			for (let i = 0; i < robots.length; ++i) {
				if (cellPos.equals(robots[i].getCell())) {
					selection.setRobot(i);
					didAction = true;
					break;
				}
			}
		}
	}
}, false);

window.addEventListener("keydown", function(event) {
	if (event.defaultPrevented) {
		return;
	}

	if (isClientSolving()) {
		if (event.key == "z" && event.ctrlKey) {
			undoMove();
		}

		if (event.key == "y" && event.ctrlKey) {
			redoMove();
		}
	}

	if (canDoMoves()) {
		if (event.key >= '1' && event.key <= '9') {
			let id = parseInt(event.key) - 1;
			if (id < robots.length) {
				selection.setRobot(id);
			}
		}

		if (selection.hasSelection()) {
			if (event.key == "ArrowRight" || event.key == 'd') {
				doDirectionMove(Direction.Right);
			}
			if (event.key == "ArrowLeft" || event.key == 'a') {
				doDirectionMove(Direction.Left);
			}
			if (event.key == "ArrowUp" || event.key == 'w') {
				doDirectionMove(Direction.Up);
			}
			if (event.key == "ArrowDown" || event.key == 's') {
				doDirectionMove(Direction.Down);
			}
			if (event.key == "Escape" || event.key == 'x') {
				selection.clearSelection();
			}
		}
	}

	//event.preventDefault();
}, true);

function clearMoveArrows() {
	MoveArrow.clearCellCounts();
	arrowSequence = [];
}

function filterArrowSequence(maxMove) {
	let pastMove = arrowSequence.findIndex(a => a.moveId >= maxMove);
	if (pastMove >= 0) {
		arrowSequence.slice(pastMove).forEach(a => a.removeCellCount());
		arrowSequence = arrowSequence.slice(0, pastMove);
	}
}

let lastLoop = 0;
function loop(timestamp) {
	let deltaTime = (timestamp - lastLoop) / 1000.0;
	lastLoop = timestamp;

	for (let i = 0; i < robots.length; ++i) {
		robots[i].update(deltaTime);
	}

	updateUI();

	drawGame(game, canvas);

	if(isAnyOf(game.state, State.Solve) || isViewingDemo()) {
		let didTween = false;
		for(let i in arrowSequence) {
			arrowSequence[i].draw(canvas);

			if (arrowSequence[i].tweenAlpha < 1.0) {
				arrowSequence[i].update(deltaTime);
				break;
			}
		}
	}

	if (activeTimer.tweenAlpha > 0) {
		activeTimer.draw(canvas);
	}

	window.requestAnimationFrame(loop);
}

function onServerMessageReceived(data) {
	let lines = data.split('\n');

	if (lines.length <= 0) {
		return;
	}

	for (let i = 0; i < lines.length; ++i) {
		let [command, ...args] = lines[i].split(' ');
		command = command.toUpperCase();
		doServerCommand(command, args);
	}
}

function doServerCommand(command, args) {
	console.log(`${command} ${args}`);

	if (command == 'GIVE_TOKENS') {
		processGiveTokens(args);
	} else if (command == 'REJECT_CLIENT') {
		processRejectClient(args);
	} else if (command == 'ASSIGN_PLAYER') {
		processAssignPlayer(args);
	} else if (command == 'NEW_BOARD') {
		processNewBoard(args);
	} else if (command == 'PLAYER_JOINED') {
		processPlayerJoined(args);
	} else if (command == 'PLAYER_LEFT') {
		processPlayerLeft(args)
	} else if (command == 'PLAYER_RENAME') {
		processRenamePlayer(args);
	} else if (command == 'PLAYER_BID') {
		processSetBid(args);
	} else if (command == 'ROBOT_MOVEALL' || command == 'ROBOT_RESET') {
		processRobotReset(args);
		if (command == 'ROBOT_RESET') {
			game.originalRobotConfig = [...cachedRobotPositions];
		}
	} else if (command == 'ROBOT_MOVE') {
		processRobotMove(args);
	} else if (command == 'ROBOT_SEQUENCE') {
		processRobotSequence(args);
	} else if (command == 'DEMO_SEQUENCE') {
		processDemoSequence(args);
	} else if (command == 'SET_STATE') {
		processSetState(args);
	} else if (command == 'TIME_SYNC') {
		processTimeSync(args);
	} else if (command == 'START_TIMER') {
		processStartTimer(args);
	} else if (command == 'CANCEL_TIMER') {
		processCancelTimer(args);
	} else if (command == 'START_SOLVE') {
		processStartSolve(args);
	} else if (command == 'PLAYER_VOTE') {
		processPlayerVote(args);
	} else if (command == 'DEMO_READY') {
		processDemoReady(args)
	} else if (command == 'DEMO_ALERT') {
		processDemoAlert(args)
	} else if (command == 'FINAL_POSITION') {
		processFinalPosition(args);
	}
}

function processPlayerVote(args) {
	let playerId = parseInt(args[0]);
	let player = game.getPlayer(playerId);
	player.vote = args[1];

	$(`#${makePlayerNodeId(playerId)} > .player_vote`).text(`Vote: ${player.vote}`);
}

function processStartSolve(args) {
	currentSolvingPlayer = parseInt(args[0]);
	serverStartTime = parseInt(args[1]);
	moveCount = 0;
	moveSequence = []
	redoStack = []

	updateUI();
}

function processStartTimer(args) {
	serverStartTime = parseInt(args[0]);
}

function processCancelTimer(args) {
	serverStartTime = null;
	activeTimer.cancel();
}

function processTimeSync(args) {
	let timeNow = Date.now();
	let roundTripTime = timeNow - parseInt(args[0]);
	let serverTime = parseInt(args[1]);
	let halfRtt = roundTripTime / 2;
	let serverTimeNow = serverTime + halfRtt;

	serverTimeDelta = serverTimeNow - timeNow;

	console.log(`Server Time Delta = ${serverTimeDelta}`);
}

function processGiveTokens(args) {
	let targetPlayerId = parseInt(args[0]);
	let tokens = args.slice(1).map(t => Goal.fromInt(parseInt(t)));
	console.assert(targetPlayerId != Number.NaN);

	game.giveTokens(targetPlayerId, tokens);

	let player = game.getPlayer(targetPlayerId);

	$(`#${makePlayerNodeId(targetPlayerId)} > .player_score`).text(`Score: ${player.tokens.length}`);
	updateTokenCount();
}

function processDemoReady(args) {
	demoAvailable = true;
}

function processDemoAlert(args) {
	if (game.state == State.Free) {
		showDemoButton.style.backgroundColor = '#FFE999';
	}
}

function processFinalPosition(args) {
	for(let i = 0; i < args.length; i += 2) {
		MoveArrow.setFinalPosition(i / 2, args[i], args[i + 1]);
	}
}

function updateTokenCount() {
	let winners = game.getWinners();
	if (winners != null && winners.length > 0) {
		let winPlural = winners.length == 1 ? 'wins' : 'win';
		$('#game_info').text(`${winners.map(p => p.name).join(', ')} ${winPlural}!`);
	} else {
		let infoText = `Tokens Remaining: ${game.goalsRemaining.length}`;
		if (game.tokensToWin != null) {
			infoText += ` | Tokens To Win: ${game.tokensToWin}`;
		}
		$('#game_info').text(infoText);
	}
}

function processNewBoard(args) {
	let numRobots = parseInt(args[0]);
	console.assert(numRobots != Number.NaN);
	let boardSeed = parseInt(args[1]);
	console.assert(boardSeed != Number.NaN);
	let tokensToWin = null;
	if (args.length > 2) {
		tokensToWin = parseInt(args[2]);
	}

	game.resetGame(numRobots, boardSeed, tokensToWin);

	robots = [];
	for (let i = 0; i < game.robots.length; ++i) {
		robots.push(new Robot(game, game.robots[i], i));
		cachedRobotPositions.push(game.robots[i]);
	}

	updateTokenCount();
}

function processSetState(args) {
	game.state = parseInt(args[0]);
	game.clearVotes();

	$(`.player_vote`).text('');

	if (args.length > 1) {
		if (isAnyOf(game.state, State.Bid, State.Solve, State.Free, State.Wait)) {
			if(args[1] != -1) {
				game.currentGoal = Goal.fromInt(parseInt(args[1]));
			} else {
				game.currentGoal = null;
			}
			moveCount = 0;
		}
	}

	if (game.state == State.Bid) {
		pendingFocusElement = bidInput;
	}

	if (game.state == State.End) {
		let rankings = game.getSortedPlayers();
		let currentRank = 1;
		for (let i = 0; i < rankings.length; ++i) {
			if (i > 0 && rankings[i].getScore() < rankings[i-1].getScore()) {
				currentRank = i + 1;
			}
			let playerNode = document.getElementById(makePlayerNodeId(rankings[i].id));
			$(`#${makePlayerNodeId(playerId)} > .player_bid`).text(`Ranking: ${currentRank}`);
		}
	}

	if (game.state == State.Wait) {
		game.resetBids();
		$('.player_bid').text('');
		demoAvailable = false;
		demoSequence = null;
	}

	cancelDemo();
	selection.clearSelection();
	serverStartTime = null;
	currentSolvingPlayer = null;
	moveSequence = []
	redoStack = []
	moveCount = null;
	showDemoButton.style.backgroundColor = '';
	activeTimer.cancel()
	MoveArrow.clearFinalPositions();
}

function processAssignPlayer(args) {
	playerId = parseInt(args[0]);
	if (game.state == State.Bid) {
		pendingFocusElement = bidInput;
	}
}

function processRejectClient(args) {
	console.log(`Server rejected client: ${args[0]}`);
	socket.close();
}

function makePlayerNodeId(playerId) {
	return `Player_${playerId}`;
}

function processPlayerJoined(args) {
	let playerId = game.addPlayer(args[1], parseInt(args[0]));
	let player = game.getPlayer(playerId);

	let playerDiv = document.getElementById('player_list');

	const playerNode = document.createElement("div");
	playerNode.id = makePlayerNodeId(player.id);
	playerNode.className = 'player_div';

	const nameNode = document.createElement('span');
	nameNode.textContent = `${player.name}`;
	nameNode.className = 'player_name';
	const scoreNode = document.createElement('span');
	scoreNode.textContent = 'Score: 0';
	scoreNode.className = 'player_score';
	const bidNode = document.createElement('span');
	bidNode.className = 'player_bid';
	const voteNode = document.createElement('span');
	voteNode.className = 'player_vote';

	playerNode.appendChild(nameNode);
	playerNode.appendChild(document.createElement("br"));
	playerNode.appendChild(scoreNode);
	playerNode.appendChild(document.createElement("br"));
	playerNode.appendChild(bidNode);
	playerNode.appendChild(document.createElement("br"));
	playerNode.appendChild(voteNode);

	playerDiv.appendChild(playerNode);
}

function processPlayerLeft(args) {
	let leftId = parseInt(args[0]);
	if (leftId == playerId) {
		playerId = null;
	}
	game.removePlayer(leftId);

	let playerNode = document.getElementById(makePlayerNodeId(leftId));
	if (playerNode != null) {
		playerNode.parentNode.removeChild(playerNode);
	}
	updateUI();
}

function processRenamePlayer(args) {
	let playerId = parseInt(args[0]);
	let name = args[1];
	game.renamePlayer(playerId, name);

	$(`#${makePlayerNodeId(playerId)} > .player_name`).text(name);
}

function processSetBid(args) {
	let playerId = parseInt(args[0]);
	let bid = parseInt(args[1]);
	let timestamp = parseInt(args[2]);
	if (bid == 0) {
		game.removeBid(playerId);
	} else {
		game.setBid(playerId, bid, timestamp);
	}

	$(`#${makePlayerNodeId(playerId)} > .player_bid`).text(`Bid: ${bid}`);
}

function processRobotReset(args) {
	for (let i = 0; i < Math.min(robots.length * 2, args.length); i += 2) {
		let robotId = intdiv(i, 2);
		let dest = new Point(parseInt(args[i]), parseInt(args[i+1]));
		cachedRobotPositions[robotId] = dest;
		if (!isViewingDemo()) {
			robots[robotId].warpTo(dest);
		}
	}
	selection.clearSelection();
	if (args.length % 2 == 1) {
		moveCount = parseInt(args[args.length - 1]);
	}

	if (!isViewingDemo()) {
		clearMoveArrows();
	}
}

function processRobotMove(args) {
	let robotId = parseInt(args[0]);

	let isUndo = false;

	if (game.state == State.Solve) {
		let oldMoveCount = moveCount;
		moveCount = parseInt(args[1]);
		isUndo = oldMoveCount > moveCount;
		filterArrowSequence(moveCount);
	}

	let moveList = [];

	for (let i = 2; i < args.length; i += 2) {
		let dest = new Point(parseInt(args[i]), parseInt(args[i + 1]));
		moveList.push(dest);
	}

	if (moveList.length > 0) {
		cachedRobotPositions[robotId] = moveList[moveList.length - 1];
	}

	if (!isViewingDemo() && moveList.length > 0 && !moveList[moveList.length - 1].equals(robots[robotId].getCell())) {
		let lastPos = robots[robotId].getCell();

		for (let i = 0; i < moveList.length; ++i) {
			robots[robotId].moveTo(moveList[i]);
			if (!isUndo && isAnyOf(game.state, State.Solve)) {
				arrowSequence.push(new MoveArrow(lastPos, moveList[i], robotId, game, moveCount - 1));

				if(i > 0) {
					arrowSequence.at(-2).connectTo(arrowSequence.at(-1));
				}
			}
			lastPos = moveList[i];
		}
	}

	if (selection.selectedRobot == robotId) {
		selection.setRobot(selection.selectedRobot);
	}

	updateUI();
}

function processDemoSequence(args) {
	if (demoSequence == null) {
		demoSequence = [];
		for (let i = 0; i < args.length; i += 2) {
			let robotId = parseInt(args[i]);
			let direction = parseInt(args[i + 1]);
			demoSequence.push(new RobotMove(game.robots[robotId], direction, robotId));
		}

		startDemo();
	}
}

function processRobotSequence(args) {
	for (let i = 0; i < args.length; i += 2) {
		let robotId = parseInt(args[i]);
		let direction = parseInt(args[i + 1]);
		let useArrows = isAnyOf(game.state, State.Solve);
		moveSequence.push(new RobotMove(game.robots[robotId], direction, robotId));
		moveCount = moveSequence.length;
		moveRobotInDirection(robotId, direction, useArrows, moveCount - 1);
	}

	for (let i = 0; i < robots.length; ++i) {
		robots[i].cancelTween();
		cachedRobotPositions[i] = robots[i].getCell();
	}
	for (let i = 0; i < arrowSequence.length; ++i) {
		arrowSequence[i].cancelTween();
	}

	updateUI();
}

let demoTimeoutId = null;

function startDemo() {
	document.getElementById('solution_indicator').textContent = `The computer found: ${demoSequence.length}`;
	demoCurrentMove = null;
	selection.clearSelection();
	advanceDemo();
	updateUI();
	console.assert(isViewingDemo());
	showDemoButton.style.backgroundColor = '';
}

function advanceDemo() {
	clearDemoTimer();

	if (demoCurrentMove == null || demoCurrentMove >= demoSequence.length) {
		game.resetRobotPositions();
		clearMoveArrows();
		for (let i = 0; i < robots.length; ++i) {
			robots[i].warpTo(game.robots[i]);
		}
		demoCurrentMove = 0;
	} else if (demoCurrentMove != null && demoCurrentMove < demoSequence.length) {
		let move = demoSequence[demoCurrentMove];
		moveRobotInDirection(move.color, move.direction, true, demoCurrentMove);
		++demoCurrentMove;
	}

	demoTimeoutId = setTimeout(advanceDemo, 1000);
	console.assert(isViewingDemo());
}

function clearDemoTimer() {
	if (demoTimeoutId != null) {
		clearTimeout(demoTimeoutId);
	}
}

function cancelDemo() {
	clearDemoTimer();
	if (isViewingDemo()) {
		clearMoveArrows();
		document.getElementById('solution_indicator').textContent = '';
		demoCurrentMove = null;
		for (let i = 0; i < robots.length; ++i) {
			robots[i].warpTo(cachedRobotPositions[i]);
		}
	}
	console.assert(!isViewingDemo());
}

function doTimeSync() {
	if (timeSyncTimeoutId != null) {
		clearTimeout(timeSyncTimeoutId);
	}

	socket.send(`SYNC_TIME ${Date.now()}`);
	timeSyncTimeoutId = setTimeout(doTimeSync, TIME_SYNC_INTERVAL);
}

window.onload = function() {
	// TODO: If this doesn't connect, just leave it in the free state, this allows you to play locally

	let targetServer = window.location.href;
	let protocolPoint = targetServer.search(':')
	let protocol = targetServer.slice(0, protocolPoint);
	let isSecure = protocol == 'https';
	let wsTarget = (isSecure ? 'wss' : 'ws') + targetServer.slice(protocolPoint);
	console.log(wsTarget)

	for (let i = 0; i < game.robots.length; ++i) {
		robots.push(new Robot(game, game.robots[i], i));
	}

	socket = new WebSocket(wsTarget);

	socket.onopen = function(event) {
		doTimeSync();
	}

	socket.onmessage = function(event) {
		console.log(`Message = ${event.data}`);
		onServerMessageReceived(event.data);
	};

	socket.onclose = function(event) {
		if (event.wasClean) {
			console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
		} else {
			// e.g. server process killed or network down
			// event.code is usually 1006 in this case
			console.log('[close] Connection died');
		}
	};

	socket.onerror = function(error) {
		console.log(`[error] ${error.message}`);
	};
};

window.onbeforeunload = function() {
    socket.onclose = function () {}; // disable onclose handler first
    socket.close();
};

bidInput.onkeypress = function(event) { return event.key in ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]; };
bidInput.onkeyup = function(event) {
	if (event.keyCode === 13) {
		// Cancel the default action, if needed
		event.preventDefault();
		// Trigger the bid
		if (canBid()) {
			executeBid();
		}
	}
};

nameInput.onkeyup = function(event) {
	if (event.keyCode === 13) {
		// Cancel the default action, if needed
		event.preventDefault();
		if (canRename()) {
			// Trigger a join or rename
			if (playerId == null) {
				joinGame();
			} else {
				tryRename();
			}
		}
	}
}

function defaultClickLambda(fn) {
	return function(ev) {
		fn();
		ev.preventDefault();
	}
}

revertButton.onclick = revertMoves;
undoButton.onclick = undoMove;
redoButton.onclick = redoMove;
skipSolveButton.onclick = skipSolve;
bidButton.onclick = executeBid;
joinButton.onclick = joinGame;
leaveButton.onclick = leaveGame;
renameButton.onclick = tryRename;
nextRoundButton.onclick = voteNextRound;
waitRoundButton.onclick = voteWaitNextRound;
gentlemanButton.onclick = voteGentleman;
resetRobotsButton.onclick = revertMoves;
showDemoButton.onclick = viewOptimal;

window.requestAnimationFrame(loop);

// TODO:
// - Add a proper random-board generation system
// - Clean up the UI, make it clearer when the state and round transition changes
// - Tag game
// - Allow selecting the settings before starting the game
// - Allow re-starting a game
// - Allow more than one game on the server
// - Change the vote types to be enums

</script>

</body>
</html>